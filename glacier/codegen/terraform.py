"""
Terraform infrastructure code generator for Glacier pipelines.
"""

import json
from typing import Any, Dict, List
from pathlib import Path


class TerraformGenerator:
    """
    Generates Terraform configuration from Glacier pipeline analysis.

    This enables "Infrastructure from Code" by automatically creating:
    1. Storage resources (S3 buckets, etc.)
    2. IAM policies and roles
    3. Networking configuration (if needed)
    4. Compute resources (for orchestration)
    """

    def __init__(self, pipeline, analysis: Dict[str, Any]):
        self.pipeline = pipeline
        self.analysis = analysis
        self.infrastructure = analysis.get("infrastructure", {})

    def generate(self, output_dir: str = "./infra") -> Dict[str, Any]:
        """
        Generate Terraform configuration files.

        Args:
            output_dir: Directory to write Terraform files

        Returns:
            Dictionary with paths to generated files and summary
        """
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        # Generate main Terraform configuration
        main_tf = self._generate_main_tf()
        self._write_file(output_path / "main.tf", main_tf)

        # Generate variables
        variables_tf = self._generate_variables_tf()
        self._write_file(output_path / "variables.tf", variables_tf)

        # Generate outputs
        outputs_tf = self._generate_outputs_tf()
        self._write_file(output_path / "outputs.tf", outputs_tf)

        # Generate terraform.tfvars example
        tfvars = self._generate_tfvars()
        self._write_file(output_path / "terraform.tfvars.example", tfvars)

        # Generate README
        readme = self._generate_readme()
        self._write_file(output_path / "README.md", readme)

        return {
            "output_dir": str(output_path),
            "files": [
                "main.tf",
                "variables.tf",
                "outputs.tf",
                "terraform.tfvars.example",
                "README.md",
            ],
            "resources": self._count_resources(),
        }

    def _generate_main_tf(self) -> str:
        """Generate main Terraform configuration."""
        resources = []

        # Provider configuration
        providers = self._get_required_providers()
        provider_config = self._format_providers(providers)

        # Generate S3 buckets
        for storage in self.infrastructure.get("storage", []):
            if storage["type"] == "s3_bucket":
                resources.append(self._generate_s3_bucket(storage))

        # Generate IAM policies
        for iam in self.infrastructure.get("iam", []):
            if iam["type"] == "s3_read_policy":
                resources.append(self._generate_s3_read_policy(iam))

        # Combine all parts
        tf_config = f"""# Generated by Glacier for pipeline: {self.pipeline.name}
# This infrastructure was automatically generated from your pipeline code.

terraform {{
  required_version = ">= 1.0"

  required_providers {{
{provider_config}
  }}
}}

{self._format_provider_blocks(providers)}

# Resources
{chr(10).join(resources)}
"""
        return tf_config

    def _generate_variables_tf(self) -> str:
        """Generate variables.tf file."""
        return f"""# Variables for {self.pipeline.name} infrastructure

variable "environment" {{
  description = "Environment name (dev, staging, prod)"
  type        = string
  default     = "dev"
}}

variable "region" {{
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}}

variable "pipeline_name" {{
  description = "Name of the Glacier pipeline"
  type        = string
  default     = "{self.pipeline.name}"
}}

variable "tags" {{
  description = "Common tags for all resources"
  type        = map(string)
  default     = {{
    ManagedBy = "Glacier"
    Pipeline  = "{self.pipeline.name}"
  }}
}}
"""

    def _generate_outputs_tf(self) -> str:
        """Generate outputs.tf file."""
        outputs = []

        # Output S3 bucket names
        for i, storage in enumerate(self.infrastructure.get("storage", [])):
            if storage["type"] == "s3_bucket":
                bucket_name = storage["name"]
                outputs.append(
                    f"""
output "s3_bucket_{i}" {{
  description = "S3 bucket for {bucket_name}"
  value       = aws_s3_bucket.{self._sanitize_name(bucket_name)}.id
}}"""
                )

        return f"""# Outputs for {self.pipeline.name} infrastructure
{chr(10).join(outputs) if outputs else "# No outputs generated"}
"""

    def _generate_tfvars(self) -> str:
        """Generate terraform.tfvars example."""
        return f"""# Example terraform.tfvars for {self.pipeline.name}
# Copy this to terraform.tfvars and customize as needed

environment   = "dev"
region        = "us-east-1"
pipeline_name = "{self.pipeline.name}"

tags = {{
  ManagedBy   = "Glacier"
  Pipeline    = "{self.pipeline.name}"
  Environment = "dev"
}}
"""

    def _generate_readme(self) -> str:
        """Generate README for the infrastructure."""
        resource_summary = self._count_resources()

        return f"""# Infrastructure for {self.pipeline.name}

This infrastructure was automatically generated by Glacier from your pipeline code.

## Resources

- **Storage**: {resource_summary['storage']} resources
- **IAM**: {resource_summary['iam']} policies
- **Total**: {resource_summary['total']} resources

## Usage

1. Review the generated Terraform files
2. Copy `terraform.tfvars.example` to `terraform.tfvars` and customize
3. Initialize Terraform:
   ```bash
   terraform init
   ```
4. Review the plan:
   ```bash
   terraform plan
   ```
5. Apply the infrastructure:
   ```bash
   terraform apply
   ```

## Pipeline Information

- **Name**: {self.pipeline.name}
- **Tasks**: {len(self.analysis.get('tasks', {}))}
- **Sources**: {len(self.analysis.get('sources', []))}

## Generated by Glacier

This infrastructure was generated from your pipeline definition.
To regenerate, run:

```bash
glacier generate your_pipeline.py --output {output_dir}
```
"""

    def _generate_s3_bucket(self, storage: Dict[str, Any]) -> str:
        """Generate Terraform for S3 bucket."""
        bucket_name = storage["name"]
        sanitized_name = self._sanitize_name(bucket_name)

        return f"""
resource "aws_s3_bucket" "{sanitized_name}" {{
  bucket = "${{var.pipeline_name}}-{bucket_name}-${{var.environment}}"

  tags = merge(var.tags, {{
    Name = "{bucket_name}"
  }})
}}

resource "aws_s3_bucket_versioning" "{sanitized_name}" {{
  bucket = aws_s3_bucket.{sanitized_name}.id

  versioning_configuration {{
    status = "Enabled"
  }}
}}

resource "aws_s3_bucket_public_access_block" "{sanitized_name}" {{
  bucket = aws_s3_bucket.{sanitized_name}.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}}
"""

    def _generate_s3_read_policy(self, iam: Dict[str, Any]) -> str:
        """Generate IAM policy for S3 read access."""
        bucket_name = iam["bucket"]
        sanitized_name = self._sanitize_name(bucket_name)

        return f"""
resource "aws_iam_policy" "{sanitized_name}_read" {{
  name        = "${{var.pipeline_name}}-{bucket_name}-read-${{var.environment}}"
  description = "Read access to {bucket_name} bucket"

  policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:ListBucket"
        ]
        Resource = [
          aws_s3_bucket.{sanitized_name}.arn,
          "${{aws_s3_bucket.{sanitized_name}.arn}}/*"
        ]
      }}
    ]
  }})

  tags = var.tags
}}
"""

    def _get_required_providers(self) -> List[str]:
        """Determine which Terraform providers are needed."""
        providers = set()

        for storage in self.infrastructure.get("storage", []):
            if storage["type"] == "s3_bucket":
                providers.add("aws")

        return list(providers)

    def _format_providers(self, providers: List[str]) -> str:
        """Format provider configuration block."""
        provider_configs = []

        for provider in providers:
            if provider == "aws":
                provider_configs.append(
                    '    aws = {\n      source  = "hashicorp/aws"\n      version = "~> 5.0"\n    }'
                )

        return "\n".join(provider_configs)

    def _format_provider_blocks(self, providers: List[str]) -> str:
        """Format provider blocks."""
        blocks = []

        for provider in providers:
            if provider == "aws":
                blocks.append(
                    """provider "aws" {
  region = var.region
}"""
                )

        return "\n\n".join(blocks)

    def _sanitize_name(self, name: str) -> str:
        """Sanitize a name for use in Terraform resource names."""
        return name.replace("-", "_").replace(".", "_").lower()

    def _count_resources(self) -> Dict[str, int]:
        """Count the number of resources of each type."""
        counts = {
            "storage": len(self.infrastructure.get("storage", [])),
            "iam": len(self.infrastructure.get("iam", [])),
            "compute": len(self.infrastructure.get("compute", [])),
            "networking": len(self.infrastructure.get("networking", [])),
        }
        counts["total"] = sum(counts.values())
        return counts

    def _write_file(self, path: Path, content: str) -> None:
        """Write content to a file."""
        with open(path, "w") as f:
            f.write(content)
